import * as fs from 'fs';
import * as path from 'path';
import { Learning } from '@code-agent-insights/core';

const SECTION_HEADER = '## Learnings from Past Sessions';
const SECTION_MARKER_START = '<!-- code-agent-insights:start -->';
const SECTION_MARKER_END = '<!-- code-agent-insights:end -->';

interface SyncOptions {
  sectionName?: string;
  includeTimestamp?: boolean;
}

export function formatLearningsSection(learnings: Learning[], options: SyncOptions = {}): string {
  const sectionName = options.sectionName || 'Learnings from Past Sessions';
  const timestamp = new Date().toISOString().split('T')[0];

  // Group learnings by type
  const grouped: Record<string, Learning[]> = {};
  for (const learning of learnings) {
    const type = learning.type;
    if (!grouped[type]) {
      grouped[type] = [];
    }
    grouped[type].push(learning);
  }

  // Build markdown
  const lines: string[] = [
    SECTION_MARKER_START,
    `## ${sectionName}`,
    '',
    `> Auto-generated by code-agent-insights. Last synced: ${timestamp}`,
    `> ${learnings.length} learnings from past coding sessions.`,
    ''
  ];

  // Order: fixes first (most actionable), then patterns, conventions, etc.
  const typeOrder = ['fix', 'pattern', 'convention', 'antipattern', 'preference', 'context'];
  const typeLabels: Record<string, string> = {
    fix: 'ðŸ”§ Fixes',
    pattern: 'âœ¨ Patterns',
    convention: 'ðŸ“ Conventions',
    antipattern: 'âš ï¸ Anti-patterns',
    preference: 'ðŸ’¡ Preferences',
    context: 'ðŸ“‹ Context'
  };

  for (const type of typeOrder) {
    if (grouped[type] && grouped[type].length > 0) {
      lines.push(`### ${typeLabels[type] || type}`);
      lines.push('');

      for (const learning of grouped[type]) {
        // Format each learning as a bullet
        let bullet = `- ${learning.content}`;

        // Add tags if present
        if (learning.tags && learning.tags.length > 0) {
          bullet += ` _(${learning.tags.join(', ')})_`;
        }

        lines.push(bullet);
      }

      lines.push('');
    }
  }

  lines.push(SECTION_MARKER_END);

  return lines.join('\n');
}

export function findClaudeMdPath(projectPath: string): string | null {
  // Check common locations
  const candidates = [
    path.join(projectPath, 'CLAUDE.md'),
    path.join(projectPath, '.claude', 'CLAUDE.md'),
    path.join(projectPath, 'docs', 'CLAUDE.md'),
  ];

  for (const candidate of candidates) {
    if (fs.existsSync(candidate)) {
      return candidate;
    }
  }

  // Default to root CLAUDE.md (will be created)
  return path.join(projectPath, 'CLAUDE.md');
}

export function mergeIntoClaudeMd(
  projectPath: string,
  learningsSection: string,
  options: { dryRun?: boolean } = {}
): {
  success: boolean;
  action: 'created' | 'updated' | 'unchanged';
  path: string;
  diff?: string;
} {
  const claudeMdPath = findClaudeMdPath(projectPath);

  if (!claudeMdPath) {
    return { success: false, action: 'unchanged', path: '', diff: 'Could not determine CLAUDE.md path' };
  }

  let existingContent = '';
  let fileExists = false;

  if (fs.existsSync(claudeMdPath)) {
    existingContent = fs.readFileSync(claudeMdPath, 'utf-8');
    fileExists = true;
  }

  let newContent: string;
  let action: 'created' | 'updated' | 'unchanged';

  // Check if our section already exists
  const hasMarkers = existingContent.includes(SECTION_MARKER_START) &&
                     existingContent.includes(SECTION_MARKER_END);

  if (hasMarkers) {
    // Replace existing section
    const beforeSection = existingContent.split(SECTION_MARKER_START)[0];
    const afterSection = existingContent.split(SECTION_MARKER_END)[1] || '';

    newContent = beforeSection.trimEnd() + '\n\n' + learningsSection + '\n' + afterSection.trimStart();
    action = 'updated';
  } else if (fileExists) {
    // Append to existing file
    newContent = existingContent.trimEnd() + '\n\n---\n\n' + learningsSection;
    action = 'updated';
  } else {
    // Create new file with basic structure
    newContent = `# Project Documentation

${learningsSection}
`;
    action = 'created';
  }

  // Check if content actually changed
  if (newContent.trim() === existingContent.trim()) {
    return { success: true, action: 'unchanged', path: claudeMdPath };
  }

  // Generate diff for dry-run
  if (options.dryRun) {
    const diff = generateSimpleDiff(existingContent, newContent);
    return { success: true, action, path: claudeMdPath, diff };
  }

  // Write the file
  try {
    // Ensure directory exists
    const dir = path.dirname(claudeMdPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(claudeMdPath, newContent, 'utf-8');
    return { success: true, action, path: claudeMdPath };
  } catch (error) {
    return {
      success: false,
      action: 'unchanged',
      path: claudeMdPath,
      diff: `Write error: ${error}`
    };
  }
}

export function removeLearningsSection(
  projectPath: string,
  options: { dryRun?: boolean } = {}
): {
  success: boolean;
  action: 'removed' | 'not_found' | 'unchanged';
  path: string;
  diff?: string;
} {
  const claudeMdPath = findClaudeMdPath(projectPath);

  if (!claudeMdPath || !fs.existsSync(claudeMdPath)) {
    return { success: true, action: 'not_found', path: claudeMdPath || '' };
  }

  const existingContent = fs.readFileSync(claudeMdPath, 'utf-8');

  // Check if our section exists
  const hasMarkers = existingContent.includes(SECTION_MARKER_START) &&
                     existingContent.includes(SECTION_MARKER_END);

  if (!hasMarkers) {
    return { success: true, action: 'not_found', path: claudeMdPath };
  }

  // Remove the section
  const beforeSection = existingContent.split(SECTION_MARKER_START)[0];
  const afterSection = existingContent.split(SECTION_MARKER_END)[1] || '';

  // Clean up extra whitespace
  let newContent = beforeSection.trimEnd();
  if (afterSection.trim()) {
    newContent += '\n\n' + afterSection.trimStart();
  }

  // Check if content actually changed
  if (newContent.trim() === existingContent.trim()) {
    return { success: true, action: 'unchanged', path: claudeMdPath };
  }

  // Generate diff for dry-run
  if (options.dryRun) {
    const diff = `Would remove learnings section from ${path.basename(claudeMdPath)}`;
    return { success: true, action: 'removed', path: claudeMdPath, diff };
  }

  // Write the file
  try {
    fs.writeFileSync(claudeMdPath, newContent, 'utf-8');
    return { success: true, action: 'removed', path: claudeMdPath };
  } catch (error) {
    return {
      success: false,
      action: 'unchanged',
      path: claudeMdPath,
      diff: `Write error: ${error}`
    };
  }
}

function generateSimpleDiff(oldContent: string, newContent: string): string {
  // Simple diff: show what would be added
  const oldLines = new Set(oldContent.split('\n'));
  const newLines = newContent.split('\n');

  const added: string[] = [];
  for (const line of newLines) {
    if (!oldLines.has(line) && line.trim()) {
      added.push(`+ ${line}`);
    }
  }

  if (added.length === 0) {
    return 'No changes';
  }

  return added.slice(0, 20).join('\n') + (added.length > 20 ? `\n... and ${added.length - 20} more lines` : '');
}
